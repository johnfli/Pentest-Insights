package com.pi.server.backend.services.util;

import java.io.File;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.Modifier;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.comments.LineComment;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.visitor.VoidVisitor;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.github.javaparser.printer.PrettyPrinter;
import com.github.javaparser.printer.PrettyPrinterConfiguration;

public class JavaParser {

	public String refactorJavaFile(String inputJavaFilePath, String inputJavaFileName) throws Exception {

		CompilationUnit cu = StaticJavaParser.parse(new File(inputJavaFilePath + inputJavaFileName));
		String outputJavaFileName = "FunctionalTest";
		// Add Package Declaration
		cu.setPackageDeclaration("securityMicroservice");
		// Remove jUnit Imports
		NodeList<ImportDeclaration> importNodes;
		importNodes = cu.getImports();
		int[] removeIndexes = {-1, -1, -1, -1, -1, -1};
		for (int i = 0; i < importNodes.size(); i++) {
			if (importNodes.get(i).toString().contains("import org.junit.Test;"))
				removeIndexes[0] = i;
			else if (importNodes.get(i).toString().contains("import org.junit.Before;"))
				removeIndexes[1] = i;
			else if (importNodes.get(i).toString().contains("import org.junit.After;"))
				removeIndexes[2] = i;
			else if (importNodes.get(i).toString().contains("import static org.junit.Assert.*;"))
				removeIndexes[3] = i;
			else if (importNodes.get(i).toString().contains("import static org.hamcrest.CoreMatchers.is;"))
				removeIndexes[4] = i;
			else if (importNodes.get(i).toString().contains("import static org.hamcrest.core.IsNot.not;"))
				removeIndexes[5] = i;
		}
		Arrays.parallelSort(removeIndexes);
		int removals = 0;
		for (int item : removeIndexes) {
			if (item != -1) {
				importNodes.remove(item - removals);
				removals++;
			}
		}
		// Add TestNG Imports
		cu.addImport("static org.testng.Assert.assertTrue");
		cu.addImport("org.testng.annotations.AfterClass");
		cu.addImport("org.testng.annotations.BeforeClass");
		cu.addImport("org.testng.annotations.Test");
		// Collect Class Names
		List<String> classNames = new ArrayList<>();
		VoidVisitor<List<String>> classCollector = new ClassCollector();
		classCollector.visit(cu, classNames);
		ClassOrInterfaceDeclaration myClass = cu.getClassByName(classNames.get(0)).get();
		myClass.setName(outputJavaFileName);
		/* Start picking the existing code */
		// Get the URL of the tested website
		String INPUT = cu.toString();
		String REGEX = "([\"'])(?:\\\\\\1|.)*?\\1";
		String url_str = null;
		Pattern p = Pattern.compile(REGEX);
		Matcher m = p.matcher(INPUT);
		boolean once = true;
		while (m.find()) {
			if((m.group(0).contains("http")) && once) {
				url_str = m.group(0);
				once = false;
			}
		}
		// Change the driver instantiation so that the browser created proxies through ZAP
		FieldDeclaration f = myClass.getFieldByName("driver").get();
		f.setModifiers(Modifier.Keyword.PUBLIC, Modifier.Keyword.STATIC);
		f = myClass.getFieldByName("vars").get();
		f.setModifiers(Modifier.Keyword.PUBLIC, Modifier.Keyword.STATIC);
		// Correct the methods as well
		List<MethodDeclaration> mds = myClass.getMethods();
		MethodCallExpr methodCallExpr;
		int i = 1;
		for(MethodDeclaration md : mds) {
			BlockStmt blockStatement;
			NameExpr nameExpr;
			if (md.isAnnotationPresent("Before")) {
				md.setAnnotation(0, new MarkerAnnotationExpr("BeforeClass"));
				blockStatement = md.getBody().get();
				blockStatement.getStatements().removeFirst();
				nameExpr = new NameExpr("PropertiesFile");
				methodCallExpr = new MethodCallExpr(nameExpr, "readPropertiesFile");
				methodCallExpr.setComment(new LineComment("Get Configuration Properties from the equivalent (config.properties) file"));
				blockStatement.addStatement(methodCallExpr);

				nameExpr = new NameExpr("WebDrivers");
				methodCallExpr = new MethodCallExpr(nameExpr, "getWebDriver");
				ExpressionStmt exp = new ExpressionStmt(new AssignExpr( new NameExpr("driver"), methodCallExpr, AssignExpr.Operator.ASSIGN));
				exp.setComment(new LineComment("Initialize Web Driver"));
				blockStatement.addStatement(exp);
				nameExpr = new NameExpr("ZAP");
				methodCallExpr = new MethodCallExpr(nameExpr, "startZAP");
				methodCallExpr.setComment(new LineComment("If not on Windows a new ZAP instance will be initiated"));
				methodCallExpr.addArgument(url_str);
				blockStatement.addStatement(methodCallExpr);

			} else if (md.isAnnotationPresent("After")){
				md.setAnnotation(0, new MarkerAnnotationExpr("AfterClass"));
				blockStatement = md.getBody().get();
				nameExpr = new NameExpr("ZAP");
				methodCallExpr = new MethodCallExpr(nameExpr, "runSecurityScans");
				methodCallExpr.setComment(new LineComment("Scans the App through ZAP"));
				blockStatement.addStatement(methodCallExpr);
				nameExpr = new NameExpr("ZAP");
				methodCallExpr = new MethodCallExpr(nameExpr, "stopZAP");
				methodCallExpr.setComment(new LineComment("Terminate ZAP Instance"));
				blockStatement.addStatement(methodCallExpr);

			} else {
				md.remove(md.getAnnotation(0));
				md.addSingleMemberAnnotation("Test", "priority="+ i);
				i++;
				blockStatement = md.getBody().get();
				NodeList<Statement> statements = blockStatement.getStatements();
				int index = 0;
				removeIndexes = new int[]{-1,-1,-1,-1,-1,-1};
				int removeIndex = 0;
				for(Statement n : statements){
					String s = n.toString();
					// Correct the driver.close problem
					if (s.contains("driver.close")) {
						removeIndexes[removeIndex] = index;
						removeIndex ++;
					}
					// Correct the assertThat Problem
					if(s.contains("assertThat")) {
						String[] arr = s.split("assertThat");
						arr = arr[1].substring(0, arr[1].length() - 1).split(", is");
						ExpressionStmt assertTrueExpr = new ExpressionStmt(new NameExpr("assertTrue" + arr[0] + ".contains" + arr[1]));
						assertTrueExpr.setComment(new LineComment(" Automated software altered this assertThat() invocation into an assertTrue() instead"));
						statements.replace(n, assertTrueExpr);

					}
					n = statements.get(index);
					String prevComment = n.getComment().toString().replace("Optional[//", "").replace("]", "");
					n.removeComment();
					s = n.toString();
					// Correct the vars.get Problem
					m = p.matcher(s);
					while (m.find()) {
						if(m.group(0).contains("vars.get")) {
							if(m.group(0).contains("\"vars.get"))
								s = s.replace("\"vars.get", "vars.get");
							else
								s = s.replace("vars.get", "\" + vars.get");

							s = s.replace("\\\"", "\"");

							if(m.group(0).contains("toString()\""))
								s = s.replace(".toString()\"", ".toString()");
							else
								s = s.replace(".toString()", ".toString() + \"");
							ExpressionStmt varsGetExpr = new ExpressionStmt(new NameExpr(s));
							varsGetExpr.setBlockComment( "\n\t\t *" + prevComment + "\t\t * Automated software altered this vars.get() invocation into a non quoted one \n\t\t ");
							statements.replace(n, varsGetExpr);
						}
					}
					index++;
				}
				Arrays.parallelSort(removeIndexes);
				removals = 0;
				for (int value : removeIndexes) {
					if (value != -1) {
						statements.remove(value - removals);
						removals++;
					}
				}
			}
		}

		// Configure Pretty Printer for better code visually
		PrettyPrinterConfiguration conf = new PrettyPrinterConfiguration();
		conf.setPrintComments(true);
		PrettyPrinter prettyPrinter = new PrettyPrinter(conf);
		// Save resulting code into a .java file
		File file;
		FileOutputStream fop;
		String outputJavaFilePath = "security-project/src/test/java/securityMicroservice/";
		file = new File(outputJavaFilePath + outputJavaFileName + ".java");
		fop = new FileOutputStream(file);
		// if file doesn't exists, then create it     
		if (!file.exists()) {
			file.createNewFile();        
		}
		// get the content in bytes        
		byte[] contentInBytes = prettyPrinter.print(cu).getBytes();
		fop.write(contentInBytes);
		fop.flush();
		fop.close();

		return url_str;
	}
}

class ClassCollector extends VoidVisitorAdapter<List<String>> {
	@Override
	public void visit(ClassOrInterfaceDeclaration md, List<String> collector) {
		super.visit(md, collector);
		collector.add(md.getNameAsString());
	}
}

